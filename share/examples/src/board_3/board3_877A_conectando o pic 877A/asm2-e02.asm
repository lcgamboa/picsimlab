; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                   CONECTANDO O PIC - RECURSOS AVANÇADOS                 *
; *                               EXEMPLO 2                                 *
; *                                                                         *
; *                NICOLÁS CÉSAR LAVINIA e DAVID JOSÉ DE SOUZA              *
; *                                                                         *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *   VERSÃO : 2.0                                                          *
; *     DATA : 24/02/2003                                                   *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                             DESCRIÇÃO GERAL                             *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  ESTE EXEMPLO FOI PREPARADO PARA DEMONSTRAR O FUNCIONAMENTO DO TIMER DE 
;  16 BITS DO PIC (TMR1) E DA VARREDURA DE DISPLAYS.
;  CONSISTE NUM TEMPORIZADOR DE SEGUNDOS. DOIS BOTÕES FORAM UTILIZADOS PARA
;  PROGRAMAR O TEMPO DA CONTAGEM. UM OUTRO BOTÃO FOI UTILIZADO PARA DISPARAR
;  O CONTADOR. O TEMPORIZADOR CONSEGUE CONTAR ATÉ 9999 SEGUNDOS, DE FORMA QUE
;  OS 4 DISPLAYS DE 7 SEGMENTOS FORAM NECESSÁRIOS. A CONTAGEM É REGRESSIVA.
;  UM LED INDICA QUE O TEMPORIZADOR ESTÁ OPERANDO. QUANDO O SISTEMA CHEGA
;  A 0000 (ZERO) O LED É DESLIGADO AUTOMATICAMENTE.
;
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                         CONFIGURAÇÕES PARA GRAVAÇÃO                     *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

 __CONFIG _CP_OFF & _CPD_OFF & _DEBUG_OFF & _LVP_OFF & _WRT_OFF & _BODEN_OFF & _PWRTE_ON & _WDT_ON & _XT_OSC

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                            DEFINIÇÃO DAS VARIÁVEIS                      *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  O PRIMEIRO BLOCO DE VARIÁVEIS ESTÁ LOCALIZADO LOGO NO INÍCIO DO BANCO 0

	CBLOCK	0X20			; POSIÇÃO INICIAL DA RAM

		UNIDADE			; (LSD)
		DEZENA			; 
		CENTENA			;
		MILHAR			; (MSD)
 
		FILTRO_BOTOES		; FILTRO PARA RUIDOS

		TEMPO_TURBO		; TEMPORIZADOR P/ TURBO DAS TECLAS

		INDICE_VARRE_DISPLAY	; INDEXADOR P/ VARREDURA DOS DISPLAYS

		DIVISOR_TMR1		; CONTADOR AUXILIAR P/ SEGUNDOS

	ENDC

;  O SEGUNDO BLOCO DE VARIÁVEIS ESTÁ LOCALIZADO NO FINAL DO BANCO 0, A PARTIR
;  DO ENDEREÇO 0X70, POIS ESTA LOCALIZAÇÃO É ACESSADA DE QUALQUER BANCO,
;  FACILITANDO A OPERAÇÃO COM AS VARIÁVEIS AQUI LOCALIZADAS.

	CBLOCK	0X70			; REGIÃO COMUM A TODOS OS BANCOS

		STATUS_TEMP		; REGISTRADOR DE STATUS TEMPORÁRIO
		WORK_TEMP		; REGISTRADOR DE TRABALHO TEMPORÁRIO
		FSR_TEMP		; REG. DE ENDERECO INDIRETO TEMPORÁRIO
		PCLATH_TEMP		; REGISTRADOR DE PAGINAÇÃO TEMPORÁRIO
	ENDC

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                DEFINIÇÃO DAS VARIÁVEIS INTERNAS DO PIC                  *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  O ARQUIVO DE DEFINIÇÕES DO PIC UTILIZADO DEVE SER REFERENCIADO PARA QUE
;  OS NOMES DEFINIDOS PELA MICROCHIP POSSAM SER UTILIZADOS, SEM A NECESSIDADE
;  DE REDIGITAÇÃO.

	#INCLUDE <P16F877A.INC>		; ARQUIVO DE DEFINIÇÕES DO PIC ATUAL

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                      DEFINIÇÃO DOS BANCOS DE RAM                        *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  OS PSEUDOS-COMANDOS "BANK0" E "BANK1", AQUI DEFINIDOS, AJUDAM A COMUTAR
;  ENTRE OS BANCOS DE MEMÓRIA.

#DEFINE	BANK1	BSF	STATUS,RP0 	; SELECIONA BANK1 DA MEMORIA RAM
#DEFINE	BANK0	BCF	STATUS,RP0	; SELECIONA BANK0 DA MEMORIA RAM

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                           CONSTANTES INTERNAS                           *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  A DEFINIÇÃO DE CONSTANTES FACILITA A PROGRAMAÇÃO E A MANUTENÇÃO.

FILTRO_TECLA	EQU	.200		; FILTRO P/ EVITAR RUIDOS DOS BOTÕES
TURBO_TECLA	EQU	.70		; TEMPORIZADOR P/ TURBO DAS TECLAS

TMR1_HIGH	EQU	HIGH (.65536-.62500)
TMR1_LOW	EQU	LOW  (.65536-.62500)	; VALOR PARA CONTAGEM DE
						; 62500 CICLOS DE CONTAGEM
						; DO TMR1 (PROGRAMADO P/
						; PRESCALER DE 1:8)

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                    DECLARAÇÃO DOS FLAGs DE SOFTWARE                    *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  A DEFINIÇÃO DE FLAGs AJUDA NA PROGRAMAÇÃO E ECONOMIZA MEMÓRIA RAM.

;  ESTE PROGRAMA NÃO UTILIZA NENHUM FLAG DE USUÁRIO

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                                ENTRADAS                                 *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  AS ENTRADAS DEVEM SER ASSOCIADAS A NOMES PARA FACILITAR A PROGRAMAÇÃO E
;  FUTURAS ALTERAÇÕES DO HARDWARE.

#DEFINE	BT_UP		PORTB,1		; ESTADO DO BOTÃO 1
					; 1 -> LIBERADO
					; 0 -> PRESSIONADO

#DEFINE	BT_DOWN		PORTB,2		; ESTADO DO BOTÃO 2
					; 1 -> LIBERADO
					; 0 -> PRESSIONADO

#DEFINE	BT_START_STOP	PORTB,3		; ESTADO DO BOTÃO 3
					; 1 -> LIBERADO
					; 0 -> PRESSIONADO

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                                 SAÍDAS                                  *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  AS SAÍDAS DEVEM SER ASSOCIADAS A NOMES PARA FACILITAR A PROGRAMAÇÃO E
;  FUTURAS ALTERAÇÕES DO HARDWARE.

#DEFINE	ESTADO_TIMER	PORTB,0		; LED DE ESTADO DO TIMER
					; (FUNCIONA TAMBÉM COMO FLAG)
					; 1 -> TIMER CONTANDO
					; 0 -> TIMER PARADO

#DEFINE	MUX		PORTB		; MUX PARA ACIONAMENTO DOS DISPLAYS
					; (DE RB4 ATÉ RB7)

#DEFINE	SEGMENTOS	PORTD		; SEGMENTOS DOS DISPLAYS

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                   VETOR DE RESET DO MICROCONTROLADOR                    *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  POSIÇÃO INICIAL PARA EXECUÇÃO DO PROGRAMA

	ORG	0X0000			; ENDEREÇO DO VETOR DE RESET
	GOTO	CONFIG_			; PULA PARA CONFIG DEVIDO A REGIÃO
					; DESTINADA ÀS INTERRUPÇÕES

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                           VETOR DE INTERRUPÇÃO                          *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  POSIÇÃO DE DESVIO DO PROGRAMA QUANDO UMA INTERRUPÇÃO ACONTECE

	ORG	0X0004			; ENDEREÇO DO VETOR DE INTERRUPÇÃO

;  É MUITO IMPORTANTE QUE OS REGISTRADORES PRIORITÁRIOS AO FUNCIONAMENTO DA
;  MÁQUINA, E QUE PODEM SER ALTERADOS TANTO DENTRO QUANTO FORA DAS INTS SEJAM
;  SALVOS EM REGISTRADORES TEMPORÁRIOS PARA PODEREM SER POSTERIORMENTE
;  RECUPERADOS.

SALVA_CONTEXTO
	MOVWF	WORK_TEMP		; SALVA REGISTRADOR DE TRABALHO E 
	SWAPF	STATUS,W		; DE STATUS DURANTE O TRATAMENTO 
	MOVWF	STATUS_TEMP		; DA INTERRUPÇÃO.
	MOVF	FSR,W
	MOVWF	FSR_TEMP		; SALVA REGISTRADOR FSR
	MOVF	PCLATH,W
	MOVWF	PCLATH_TEMP		; SALVA REGISTRADOR PCLATH

	CLRF	PCLATH			; LIMPA REGISTRADOR PCLATH
					; (SELECIONA PÁGINA 0)
	CLRF	STATUS			; LIMPA REGISTRADOR STATUS
					; (SELECIONA BANCO 0)

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                 TESTA QUAL INTERRUPÇÃO FOI SOLICITADA                   *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  TESTA O FLAG DAS INTERRUPÇÕES PARA SABER PARA QUAL ROTINA DESVIAR.

	BTFSS	INTCON,T0IF		; FOI INTERRUPÇÃO DE TMR0 ?
	GOTO	INT_TMR1		; NÃO - ENTÃO PULA P/ INT_TMR1
					; SIM

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                    TRATAMENTO DA INTERRUPÇÃO DE TIMER 0                 *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  ROTINA PARA EXECUTAR AS AÇÕES NECESSÁRIAS SEMPRE QUE A INTERRUPÇÃO
;  ACONTECE. NESTE CASO, A INTERRUPÇÃO ESTA SENDO UTILIZADA PARA GERAR A
;  FREQÜÊNCIA DE VARREDURA DOS DISPLAYS. POR ISSO, CADA VEZ QUE ELA ACONTECER,
;  O PRÓXIMO DISPLAY SERÁ ACIONADO.

INT_TMR0
	INCF	INDICE_VARRE_DISPLAY,F	; INCR. O ÍNDICE DE VAR. DOS DISPLAYS

	MOVLW	B'00000011'
	ANDWF	INDICE_VARRE_DISPLAY,F	; LIMITA CONTAGEM DE 0 A 3

	MOVF	INDICE_VARRE_DISPLAY,W	; CARREGA NO WORK O VALOR DO ÍNDICE
	ADDLW	UNIDADE			; SOMA ENDEREÇO DO PRIMEIRO DÍGITO
	MOVWF	FSR			; SALVA RESULTADO NO FSR, APONTANDO
					; PARA O ENDEREÇO DO DÍGITO ATUAL.
					; (ENDEREÇAMENTO INDIRETO)

	CLRF	SEGMENTOS		; LIMPA OS SEGMENTOS (BLANK)
					; UTILIZADO P/ EVITAR SOMBRAS NOS
					; DISPLAYS

	MOVLW	B'00001111'		; PREPARA MÁSCARA
	ANDWF	MUX,F			; EXECUTA MÁSCARA (DESLIGA OS DISP.)

	MOVF	INDICE_VARRE_DISPLAY,W	; SALVA NO WORK O VALOR DO ÍNDICE
	CALL	TABELA_MUX		; CONSULTA TABELA MUX
	IORWF	MUX,F			; ATUALIZA MUX, SELECIONANDO O
					; DISPLAYS CORRETO PARA O MOMENTO

	GOTO	$+1			; DELAY DE 2US
					; (TEMPO DE RESPOSTA DO TRANSISTOR)

	MOVF	INDF,W			; RECUPERA NO WORK O VALOR DO DÍGITO
	CALL	TABELA_DISPLAY_7_SEG	; CONSULTA TABELA P/ DISPLAYS
	MOVWF	SEGMENTOS		; ATUALIZA OS SEGMENTOS, ESCREVENDO
					; O VALOR DO DÍGITO CORRETO (PORTD)

SAI_INT_TMR0
	BCF	INTCON,T0IF		; LIMPA FLAG DA INTERRUPÇÃO DE TMR0
	GOTO	SAI_INT			; PULA P/ SAI_INT

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                    TRATAMENTO DA INTERRUPÇÃO DE TIMER 1                 *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  ROTINA PARA EXECUTAR AS AÇÕES NECESSÁRIAS SEMPRE QUE A INTERRUPÇÃO
;  ACONTECE. NESTE CASO, A INTERRUPÇÃO ESTA SENDO UTILIZADA PARA CONTAR O
;  TEMPO DO TEMPORIZADOR. POR ISSO, CADA VEZ QUE ELA ACONTECER O VALOR DO
;  TIMER SERÁ DECREMENTADO, CASO JÁ TENHA SE PASSADO 1SEG. 
;  PERIODO DA INTERRUPÇÃO: 1US (CICLO DE MAQUINA) * 8 (PRESCALER DO TMR1) *
; 			   * 62500 (CONTAGEM DO TMR1) = 0,5SEG.

INT_TMR1
	MOVLW	TMR1_HIGH
	MOVWF	TMR1H
	MOVLW	TMR1_LOW
	MOVWF	TMR1L			; RECARREGA CONTADOR DO TMR1
					; PERIODICIDADE DE 0,5SEG.

	DECFSZ	DIVISOR_TMR1,F		; PASSOU-SE 1 SEGUNDO ?
	GOTO	SAI_INT_TMR1		; NÃO - ENTÃO SAI DA INTERRUPÇÃO
					; SIM
	MOVLW	.2
	MOVWF	DIVISOR_TMR1		; RECARREGA CONTADOR DE 1SEG.

	CALL	DECREMENTA_TIMER	; DECREMENTA O VALOR DO TIMER

	MOVF	UNIDADE,F
	BTFSS	STATUS,Z
	GOTO	SAI_INT_TMR1
	MOVF	DEZENA,F
	BTFSS	STATUS,Z
	GOTO	SAI_INT_TMR1
	MOVF	CENTENA,F
	BTFSS	STATUS,Z
	GOTO	SAI_INT_TMR1
	MOVF	MILHAR,F
	BTFSS	STATUS,Z		; FINAL DA CONTAGEM ? (TIMER=0?)
	GOTO	SAI_INT_TMR1		; NÃO - SAI DA INTERRUPÇÃO
					; SIM
	BCF	ESTADO_TIMER		; DESLIGA LED DE TIMER OPERANDO
	BCF	T1CON,TMR1ON		; PARALIZA CONTADOR DO TMR1

SAI_INT_TMR1
	BCF	PIR1,TMR1IF		; LIMPA FLAG DA INTERRUPÇÃO DE TMR1

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                           SAÍDA DA INTERRUPÇÃO                          *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  ANTES DE SAIR DA INTERRUPÇÃO, O CONTEXTO SALVO NO INÍCIO DEVE SER
;  RECUPERADO PARA QUE O PROGRAMA NÃO SOFRA ALTERAÇÕES INDESEJADAS.

SAI_INT
	MOVF	PCLATH_TEMP,W
	MOVWF	PCLATH			; RECUPERA REG. PCLATH (PAGINAÇÃO)
	MOVF	FSR_TEMP,W
	MOVWF	FSR			; RECUPERA REG. FSR (END. INDIRETO)
	SWAPF	STATUS_TEMP,W
	MOVWF	STATUS			; RECUPERA REG. STATUS
	SWAPF	WORK_TEMP,F
	SWAPF	WORK_TEMP,W		; RECUPERA REG. WORK
	RETFIE				; RETORNA DA INTERRUPÇÃO (HABILITA GIE)

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                 TABELA PARA OS DISPLAYS DE 7 SEGMENTOS                  *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  ROTINA PARA CONVERSÃO DO VALOR NÚMÉRICO DO DÍGITO EM RELAÇÃO AOS SEGMENTOS
;  QUE DEVEM SER ACESOS E APAGADOS NO DISPLAY

TABELA_DISPLAY_7_SEG
	ANDLW	B'00001111'		; EXECUTA MASCARA P/ EVITAR PULOS ERRADOS
	ADDWF	PCL,F			; SOMA DESLOCAMENTO AO PROGRAM COUNTER,
					; GERANDO UMA TABELA DO TIPO "CASE".
;	          PGFEDCBA		; POSIÇÃO RELATIVA AOS SEGMENTOS
	RETLW	B'00111111'		; 0H - 0
	RETLW	B'00000110'		; 1H - 1
	RETLW	B'01011011'		; 2H - 2
	RETLW	B'01001111'		; 3H - 3
	RETLW	B'01100110'		; 4H - 4
	RETLW	B'01101101'		; 5H - 5
	RETLW	B'01111101'		; 6H - 6
	RETLW	B'00000111'		; 7H - 7
	RETLW	B'01111111'		; 8H - 8
	RETLW	B'01101111'		; 9H - 9
	RETLW	B'00000000'		; AH - BLANK
	RETLW	B'00000000'		; BH - BLANK
	RETLW	B'00000000'		; CH - BLANK
	RETLW	B'00000000'		; DH - BLANK
	RETLW	B'00000000'		; EH - BLANK
	RETLW	B'00000000'		; FH - BLANK

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                 TABELA PARA ACIONAMENTO DOS DISPLAYS                    *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  ROTINA PARA CONVERTER O DÍGITO ATUAL EM RELAÇÃO AO PORT QUE DEVE SER
;  LIGADO PARA ACIONAMENTO DO DISPLAY RELACIONADO.

TABELA_MUX
	ADDWF	PCL,F			; SOMA DESLOCAMENTO AO PROGRAM COUNTER
					; GERANDO UMA TABELA DO TIPO "CASE".
	RETLW	B'00010000'		; 0 - ACIONA DISPLAY 0
	RETLW	B'00100000'		; 1 - ACIONA DISPLAY 1
	RETLW	B'01000000'		; 2 - ACIONA DISPLAY 2
	RETLW	B'10000000'		; 2 - ACIONA DISPLAY 3

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *              ROTINA PARA INCREMENTAR O VALOR DO TIMER (BCD)             *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  ROTINA UTILIZADA PARA INCREMENTAR O VALOR DOS REGISTRADORES UNIDADE,
;  DEZENA, CENTENA E MILHAR, QUE SÃO OS CONTADORES DO TIMER. A CONTAGEM É
;  FEITA DIRETAMENTE EM BCD.

INCREMENTA_TIMER
	INCF	UNIDADE,F		; INCREMENTA UNIDADE

	MOVLW	.10
	XORWF	UNIDADE,W
	BTFSS	STATUS,Z		; UNIDADE = 10 ?
	RETURN				; NÃO - RETORNA
					; SIM
	CLRF	UNIDADE			; ZERA A UNIDADE
	INCF	DEZENA,F		; INCREMENTA A DEZENA

	MOVLW	.10
	XORWF	DEZENA,W
	BTFSS	STATUS,Z		; DEZENA = 10 ?
	RETURN				; NÃO - RETORNA
					; SIM
	CLRF	DEZENA			; ZERA A DEZENA
	INCF	CENTENA,F		; INCREMENTA A CENTENA

	MOVLW	.10
	XORWF	CENTENA,W
	BTFSS	STATUS,Z		; CENTENA = 10 ?
	RETURN				; NÃO - RETORNA
					; SIM
	CLRF	CENTENA			; ZERA A CENTENA
	INCF	MILHAR,F		; INCREMENTA O MILHAR

	MOVLW	.10
	XORWF	MILHAR,W
	BTFSC	STATUS,Z		; MILHAR = 10 ?
	CLRF	MILHAR			; SIM - ZERA MILHAR
	RETURN				; NÃO - RETORNA

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *              ROTINA PARA DECREMENTAR O VALOR DO TIMER (BCD)             *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  ROTINA UTILIZADA PARA DECREMENTAR O VALOR DOS REGISTRADORES UNIDADE,
;  DEZENA, CENTENA E MILHAR, QUE SÃO OS CONTADORES DO TIMER. A CONTAGEM É
;  FEITA DIRETAMENTE EM BCD.

DECREMENTA_TIMER
	DECF	UNIDADE,F		; INCREMENTA UNIDADE

	MOVLW	0XFF
	XORWF	UNIDADE,W
	BTFSS	STATUS,Z		; UNIDADE = 0XFF ?
	RETURN				; NÃO - RETORNA
					; SIM
	MOVLW	.9
	MOVWF	UNIDADE			; CARREGA UNIDADE COM 9
	DECF	DEZENA,F		; DECREMENTA A DEZENA

	MOVLW	0XFF
	XORWF	DEZENA,W
	BTFSS	STATUS,Z		; DEZENA = 0XFF ?
	RETURN				; NÃO - RETORNA
					; SIM
	MOVLW	.9
	MOVWF	DEZENA			; CARREGA A DEZENA COM 9
	DECF	CENTENA,F		; DECREMENTA A CENTENA

	MOVLW	0XFF
	XORWF	CENTENA,W
	BTFSS	STATUS,Z		; CENTENA = 0XFF ?
	RETURN				; NÃO - RETORNA
					; SIM
	MOVLW	.9
	MOVWF	CENTENA			; CARREGA CENTENA COM 9
	DECF	MILHAR,F		; DECREMENTA O MILHAR

	MOVLW	0XFF
	XORWF	MILHAR,W
	BTFSS	STATUS,Z		; MILHAR = 0XFF ?
	RETURN				; NÃO - RETORNA
					; SIM
	MOVLW	.9
	MOVWF	MILHAR			; CARREGA O MILHAR COM 9
	RETURN				; RETORNA

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                CONFIGURAÇÕES INICIAIS DE HARDWARE E SOFTWARE            *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  NESTA ROTINA SÃO INICIALIZADAS AS PORTAS DE I/O DO MICROCONTROLADOR E AS
;  CONFIGURAÇÕES DOS REGISTRADORES ESPECIAIS (SFR). A ROTINA INICIALIZA A
;  MÁQUINA E AGUARDA O ESTOURO DO WDT.

CONFIG_
	CLRF	PORTA			; GARANTE TODAS AS SAÍDAS EM ZERO
	CLRF	PORTB
	CLRF	PORTC
	CLRF	PORTD
	CLRF	PORTE

	BANK1				; SELECIONA BANCO 1 DA RAM

	MOVLW	B'11111111'
	MOVWF	TRISA			; CONFIGURA I/O DO PORTA

	MOVLW	B'00001110'
	MOVWF	TRISB			; CONFIGURA I/O DO PORTB

	MOVLW	B'11111111'
	MOVWF	TRISC			; CONFIGURA I/O DO PORTC

	MOVLW	B'00000000'
	MOVWF	TRISD			; CONFIGURA I/O DO PORTD

	MOVLW	B'00000111'
	MOVWF	TRISE			; CONFIGURA I/O DO PORTE

	MOVLW	B'11011111'
	MOVWF	OPTION_REG		; CONFIGURA OPTIONS
					; PULL-UPs DESABILITADOS
					; INTER. NA BORDA DE SUBIDA DO RB0
					; TIMER0 INCREM. PELO CICLO DE MÁQUINA
					; WDT   - 1:128
					; TIMER0- 1:1
					
	MOVLW	B'01100000'		
	MOVWF	INTCON			; CONFIGURA INTERRUPÇÕES
					; HABILITADA A INTERRUPÇÃO DE TIMER0
					; HABILITA AS INTERRUPÇÕES DE PERIFÉRICO

	MOVLW	B'00000001'
	MOVWF	PIE1			; CONFIGURA INTERRUPÇÕES DE PERIFIÉRICOS
					; HABILITADA A INTERRUPÇÃO DE TMR1
	MOVLW	B'00000111'
	MOVWF	ADCON1			; CONFIGURA CONVERSOR A/D
					; CONFIGURA PORTA E PORTE COMO I/O DIGITAL

	BANK0				; SELECIONA BANCO 0 DA RAM

	MOVLW	B'00110000'
	MOVWF	T1CON			; CONFIGURA TMR1
					; PRESCALER -> 1:8
					; INCREMENTADO PELO CICLO DE MÁQUINA

;  AS INSTRUÇÕES A SEGUIR FAZEM COM QUE O PROGRAMA TRAVE QUANDO HOUVER UM
;  RESET OU POWER-UP, MAS PASSE DIRETO SE O RESET FOR POR WDT. DESTA FORMA,
;  SEMPRE QUE O PIC É LIGADO, O PROGRAMA TRAVA, AGUARDA UM ESTOURO DE WDT
;  E COMEÇA NOVAMENTE. ISTO EVITA PROBLEMAS NO START-UP DO PIC.

	BTFSC	STATUS,NOT_TO		; RESET POR ESTOURO DE WATCHDOG TIMER?
	GOTO	$			; NÃO - AGUARDA ESTOURO DO WDT
					; SIM

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                         INICIALIZAÇÃO DA RAM                            *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  ESTA ROTINA IRÁ LIMPAR TODA A RAM DO BANCO 0, INDO DE 0X20 A 0X7F.
;  EM SEGUIDA, AS VARIÁVEIS DE RAM DO PROGRAMA SÃO INICIALIZADAS.

	MOVLW	0X20
	MOVWF	FSR			; APONTA O ENDEREÇAMENTO INDIRETO PARA
					; A PRIMEIRA POSIÇÃO DA RAM
LIMPA_RAM
	CLRF	INDF			; LIMPA A POSIÇÃO
	INCF	FSR,F			; INCREMENTA O PONTEIRO P/ A PRÓX. POS.
	MOVF	FSR,W
	XORLW	0X80			; COMPARA O PONTEIRO COM A ÚLT. POS. +1
	BTFSS	STATUS,Z		; JÁ LIMPOU TODAS AS POSIÇÕES?
	GOTO	LIMPA_RAM		; NÃO - LIMPA A PRÓXIMA POSIÇÃO
					; SIM

	BCF	ESTADO_TIMER		; INICIA COM ESTADO EM OFF

	MOVLW	.2
	MOVWF	DIVISOR_TMR1		; CARREGA CONTADOR DE 1SEG.

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                          VARREDURA DOS BOTÕES                           *
; *                             LOOP PRINCIPAL                              *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  A ROTINA PRINCIPAL FICA CHECANDO O ESTADO DOS BOTÕES. CASO ALGUM SEJA
;  PRESSIONADO, A ROTINA DE TRATAMENTO DO BOTÃO É CHAMADA.

	BSF	INTCON,GIE		; HABILITA AS INTERRUPÇÕES
					; USADA INT. TMR0 PARA VARREDURA
					; DOS DISPLAYS

VARRE
	CLRWDT				; LIMPA WATCHDOG TIMER

	BTFSS	BT_UP			; O BOTÃO DE UP ESTÁ PRESSIONADO?
	GOTO	TRATA_BT_UP		; SIM - PULA P/ TRATA_BT_UP
					; NÃO

	BTFSS	BT_DOWN			; O BOTÃO DE DOWN ESTÁ PRESSIONADO?
	GOTO	TRATA_BT_DOWN		; SIM - PULA P/ TRATA_BT_DOWN
					; NÃO

	BTFSS	BT_START_STOP		; O BOTÃO START/STOP ESTÁ PRESSIONADO?
	GOTO	TRATA_BT_START_STOP	; SIM - PULA P/ TRATA_BT_START_STOP
					; NÃO

	MOVLW	FILTRO_TECLA		; CARREGA NO WORK O VALOR DE FILTRO_TECLA
	MOVWF	FILTRO_BOTOES		; SALVA EM FILTRO_BOTOES
					; RECARREGA FILTRO P/ EVITAR RUIDOS

	MOVLW	.1
	MOVWF	TEMPO_TURBO		; CARREGA TEMPO DO TURBO DAS TECLAS
					; COM 1 - IGNORA O TURBO A PRIMEIRA
					; VEZ QUE A TECLA É PRESSIONADA

	GOTO	VARRE			; VOLTA PARA VARRER TECLADO

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                         TRATAMENTO DOS BOTÕES                           *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

; ************************* TRATAMENTO DO BOTÃO DE UP ***********************

TRATA_BT_UP
	BTFSC	ESTADO_TIMER		; TIMER ESTÁ PARADO ?
	GOTO	VARRE			; NÃO - VOLTA P/ VARRE
					; SIM

	DECFSZ	FILTRO_BOTOES,F		; FIM DO FILTRO ? (RUIDO?)
	GOTO	VARRE			; NÃO - VOLTA P/ VARRE
					; SIM - BOTÃO PRESSIONADO

	DECFSZ	TEMPO_TURBO,F		; FIM DO TEMPO DE TURBO ?
	GOTO	VARRE			; NÃO - VOLTA P/ VARRE
					; SIM
	MOVLW	TURBO_TECLA
	MOVWF	TEMPO_TURBO		; RECARREGA TEMPORIZADOR DO TURBO
					; DAS TECLAS

	CALL	INCREMENTA_TIMER	; INCREMENTA O VALOR DO TIMER

	GOTO	VARRE			; VOLTA P/ VARREDURA DOS BOTÕES

; ************************* TRATAMENTO DO BOTÃO DE DOWN **********************

TRATA_BT_DOWN
	BTFSC	ESTADO_TIMER		; TIMER ESTÁ PARADO ?
	GOTO	VARRE			; NÃO - VOLTA P/ VARRE
					; SIM

	DECFSZ	FILTRO_BOTOES,F		; FIM DO FILTRO ? (RUIDO?)
	GOTO	VARRE			; NÃO - VOLTA P/ VARRE
					; SIM - BOTÃO PRESSIONADO

	DECFSZ	TEMPO_TURBO,F		; FIM DO TEMPO DE TURBO ?
	GOTO	VARRE			; NÃO - VOLTA P/ VARRE
					; SIM
	MOVLW	TURBO_TECLA
	MOVWF	TEMPO_TURBO		; RECARREGA TEMPORIZADOR DO TURBO
					; DAS TECLAS

	CALL	DECREMENTA_TIMER	; DECREMENTA O VALOR DO TIMER

	GOTO	VARRE			; VOLTA P/ VARREDURA DOS BOTÕES

; ************************* TRATAMENTO DO BOTÃO START / STOP *****************

TRATA_BT_START_STOP
	MOVF	FILTRO_BOTOES,F
	BTFSC	STATUS,Z		; FILTRO JÁ IGUAL A ZERO ?
					; (FUNÇÃO JÁ FOI EXECUTADA?)		
	GOTO	VARRE			; SIM - VOLTA P/ VARREDURA DO TECLADO
					; NÃO

	DECFSZ	FILTRO_BOTOES,F		; FIM DO FILTRO ? (RUIDO?)
	GOTO	VARRE			; NÃO - VOLTA P/ VARRE
					; SIM - BOTÃO PRESSIONADO


	BTFSS	ESTADO_TIMER		; TIMER ESTA LIGADO ?
	GOTO	LIGA_TIMER		; NÃO - ENTÃO LIGA
					; SIM - ENTÃO DESLIGA

DESLIGA_TIMER
	BCF	ESTADO_TIMER		; DESLIGA LED E FLAG DO ESTADO DO TIMER
	BCF	T1CON,TMR1ON		; PARA CONTADOR DO TMR1
	GOTO	VARRE			; VOLTA P/ VARREDURA DOS BOTÕES

LIGA_TIMER
	MOVF	UNIDADE,F
	BTFSS	STATUS,Z		; UNIDADE ESTÁ ZERADA ?
	GOTO	LIGA_TIMER_2		; NÃO - PULA P/ LIGA_TIMER_2
					; SIM - TESTA DEZENA
	MOVF	DEZENA,F
	BTFSS	STATUS,Z		; DEZENA ESTÁ ZERADA ?
	GOTO	LIGA_TIMER_2		; NÃO - PULA P/ LIGA_TIMER_2
					; SIM - TESTA CENTENA
	MOVF	CENTENA,F
	BTFSS	STATUS,Z		; CENTENA ESTÁ ZERADA ?
	GOTO	LIGA_TIMER_2		; NÃO - PULA P/ LIGA_TIMER_2
					; SIM - TESTA MILHAR
	MOVF	MILHAR,F
	BTFSS	STATUS,Z		; MILHAR ESTÁ ZERADO ?
	GOTO	LIGA_TIMER_2		; NÃO - PULA P/ LIGA_TIMER_2
	GOTO	VARRE			; SIM - VOLTA P/ VARRER TECLADO
					;       SEM LIGAR O TIMER

LIGA_TIMER_2
	BSF	ESTADO_TIMER		; LIGA LED E FLAG DO ESTADO DO TIMER

	MOVLW	TMR1_HIGH
	MOVWF	TMR1H
	MOVLW	TMR1_LOW
	MOVWF	TMR1L			; INICIALIZA CONTADORES

	MOVLW	.2
	MOVWF	DIVISOR_TMR1		; INICIALIZA DIVISOR

	BSF	T1CON,TMR1ON		; LIGA CONTAGEM DO TMR1

	GOTO	VARRE			; VOLTA P/ VARREDURA DOS BOTÕES

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                              FIM DO PROGRAMA                            *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	END				; FIM DO PROGRAMA

