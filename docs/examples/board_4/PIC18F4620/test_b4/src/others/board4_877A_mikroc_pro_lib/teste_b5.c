/* ########################################################################

   PICsim - PIC simulator http://sourceforge.net/projects/picsim/

   ########################################################################

   Copyright (c) : 2011  Luis Claudio Gambôa Lopes

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

   For e-mail suggestions :  lcgamboa@yahoo.com
   ######################################################################## */

/* ----------------------------------------------------------------------- */
/* Template source file generated by piklab */


#include "display7s.h"

// LCD module connections
sbit LCD_RS at RE2_bit;
sbit LCD_EN at RE1_bit;
sbit LCD_D4 at RD4_bit;
sbit LCD_D5 at RD5_bit;
sbit LCD_D6 at RD6_bit;
sbit LCD_D7 at RD7_bit;

sbit LCD_RS_Direction at TRISE2_bit;
sbit LCD_EN_Direction at TRISE1_bit;
sbit LCD_D4_Direction at TRISD4_bit;
sbit LCD_D5_Direction at TRISD5_bit;
sbit LCD_D6_Direction at TRISD6_bit;
sbit LCD_D7_Direction at TRISD7_bit;
// End LCD module connections

char* codetxt_to_ramtxt(const char* ctxt){
static char txt[40];
char i;
  for(i =0; txt[i] = ctxt[i]; i++);
  return txt;
}

void main()
{
  unsigned char i;
  unsigned char tmp;
  unsigned int tmpi;
  unsigned int tout;

  char str[6];

  ADCON1=0x06;
  TRISA=0xC3;
  TRISB=0x01;
  TRISC=0x01;
  TRISD=0x00;
  TRISE=0x00;

  NOT_RBPU_bit=0;

  lcd_init();
  UART1_Init(9600);
  adc_init();


/*
//dip
  TRISB=0x03;
  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp(codetxt_to_ramtxt("Ligue todos DIP"));
  lcd_cmd(_LCD_SECOND_ROW);
  lcd_out_cp(codetxt_to_ramtxt("Press. RB1"));
  while(RB1_bit);
*/

//testa caracter especial
  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp(codetxt_to_ramtxt("   Teste LCD"));

  lcd_cmd(0x40);//endere�o

  lcd_chr_cp(0x11);
  lcd_chr_cp(0x19);
  lcd_chr_cp(0x15);
  lcd_chr_cp(0x13);
  lcd_chr_cp(0x13);
  lcd_chr_cp(0x15);
  lcd_chr_cp(0x19);
  lcd_chr_cp(0x11);

  lcd_chr_cp(0x0E);
  lcd_chr_cp(0x11);
  lcd_chr_cp(0x0E);
  lcd_chr_cp(0x05);
  lcd_chr_cp(0x0E);
  lcd_chr_cp(0x14);
  lcd_chr_cp(0x0A);
  lcd_chr_cp(0x11);


  lcd_cmd(_LCD_SECOND_ROW);

  for(i=0;i<16;i++)
  {
    lcd_chr_cp(i%2);
    delay_ms(100);
  }

//teste lcd
  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp(codetxt_to_ramtxt("   Teste LCD"));
  
  for(i=32;i<128;i++)
  {
    if((i%16) == 0)lcd_cmd(_LCD_SECOND_ROW);
    lcd_chr_cp(i);
    delay_ms(50);
  }

  delay_ms(100);
  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp(codetxt_to_ramtxt("   Teste LCD"));
  lcd_cmd(_LCD_SECOND_ROW);
  lcd_out_cp(codetxt_to_ramtxt("       Ok"));
  delay_ms(500);




//testa display 7s

  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp(codetxt_to_ramtxt("   Teste 7 Seg"));


   ADCON1=0x06;
    for(i=0;i<4;i++)
    {
      switch(i)
      {
         case 0: 
           PORTA=0x20;
           break;
         case 1: 
           PORTA=0x10;
           break;
         case 2: 
           PORTA=0x08;
           break;
         case 3: 
           PORTA=0x04;
           break;
       }

      for(tmp=0;tmp<16;tmp++)
      {
        PORTD=display7s(tmp);         
        delay_ms(200);
      }
    }

  ADCON1=0x02;
  PORTD=0;

/*
//dip
  TRISB=0x03;
  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp(codetxt_to_ramtxt("Desligue RTC DIP"));
  lcd_cmd(_LCD_SECOND_ROW);
  lcd_out_cp(codetxt_to_ramtxt("Press. RB1"));
  while(RB1_bit);
*/

//testa LEDs
  TRISB=0x00;
  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW+3);
  lcd_out_cp(codetxt_to_ramtxt("Teste LEDs"));

  for(tmp=0;tmp<3;tmp++)
    {
      for(i=1;i > 0;i=i*2)
      { 
        PORTB=i;
        PORTD=i; 
        delay_ms(200);
      }
    }
  PORTB=0;
  PORTD=0;
  for(i=0;i<4;i++)
  {
    PORTB^=0xFF;
    PORTD^=0xFF;
    delay_ms(200);
  }  

//testa chaves


  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp(codetxt_to_ramtxt("  Teste Chaves"));

  tmp=0;
  ADCON1=0x06;
  TRISA|=0x20;

  while((tmp & 0x7F) != 0x7F)
  {
    TRISB=0x3F;

    if(RB0_bit == 0)
    {
      tmp|=0x01;
    }
    if(RB1_bit == 0)
    {
      tmp|=0x02;
    }
    if(RB2_bit == 0)
    {
      tmp|=0x04;
    }
    if(RB3_bit == 0)
    {
      tmp|=0x08;
    }
    if(RB4_bit == 0)
    {
      tmp|=0x10;
    }
    if(RB5_bit == 0)
    {
      tmp|=0x20;
    }
    if(RA5_bit == 0)
    {
      tmp|=0x40;
    }

    
    TRISB=0x00;
    PORTB=tmp;
    delay_ms(10);
  }

    delay_ms(500);

  PORTB=0; 
  ADCON1=0x02;


 




  TRISC7_bit=1; //RX
  TRISC6_bit=0; //TX

//teste serial
  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp(codetxt_to_ramtxt("Teste Serial TX"));
  lcd_cmd(_LCD_SECOND_ROW+4);
  lcd_out_cp(codetxt_to_ramtxt("9600 8N1"));

  uart1_write_text(codetxt_to_ramtxt("\r\n Picsimlab\r\n Teste Serial TX\r\n"));

  for(i=0;i<4;i++)
  {
    uart1_write(i+0x30);
    uart1_write_text(codetxt_to_ramtxt(" PicsimLab\r\n"));
  }
  delay_ms(1000);

  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp(codetxt_to_ramtxt("Teste Serial RX"));
  uart1_write_text(codetxt_to_ramtxt(" Digite!\r\n"));
  for(i=0;i<32;i++)
  {
    if(!(i%16))
    {
       lcd_cmd(_LCD_SECOND_ROW);
       uart1_write_text(codetxt_to_ramtxt("\r\n"));
    }
    
    tout=0;
    while((!uart1_data_ready())&&(tout<2000))
    {
      tout++;
      delay_ms(1);
    }
    if(uart1_data_ready())
    {
      tmp=uart1_read();
    }
    else
    {
      tmp='-';
    }
    lcd_chr_cp(tmp);
    uart1_write(tmp);
  }
  delay_ms(100);



//teste ADC
  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp(codetxt_to_ramtxt(" Teste ADC (P1)"));

  for(i=0; i< 200; i++)
  {
    tmp=(adc_read(0)*10)/204;
    lcd_cmd(_LCD_SECOND_ROW+6);
    inttostr(tmp,str);
    if(str[4] == ' ')
      lcd_chr_cp('0');
    else
      lcd_chr_cp(str[4]);
    lcd_chr_cp(',');
    lcd_chr_cp(str[5]);
    lcd_chr_cp('V');
    delay_ms(10);
  }

  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp(codetxt_to_ramtxt(" Teste ADC (P2)"));

  for(i=0; i< 200; i++)
  {
    tmp=((unsigned int)adc_read(1)*10)/204;
    lcd_cmd(_LCD_SECOND_ROW+6);
    inttostr(tmp,str);
    if(str[4] == ' ')
      lcd_chr_cp('0');
    else
      lcd_chr_cp(str[4]);
    lcd_chr_cp(',');
    lcd_chr_cp(str[5]);
    lcd_chr_cp('V');
    delay_ms(10);
  }


//teste RELE

  TRISC0_bit=0;
  TRISE0_bit=0;

  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp(codetxt_to_ramtxt("Teste RELE 1 2"));

  
  for(i=0;i<5;i++)
  {
    RC0_bit^=1;
    RE0_bit^=1;
    delay_ms(500);
  }
  RC0_bit=0;
  RE0_bit=0;
    
  /*
  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp(codetxt_to_ramtxt("Teste RELE 2"));

  for(i=0;i<5;i++)
  {
    RE0_bit^=1;
    delay_ms(500);
  }
  RE0_bit=0;
 */
 

//fim teste 
  lcd_cmd(_LCD_CLEAR);

  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp(codetxt_to_ramtxt("      Fim"));
/*
  lcd_cmd(_LCD_SECOND_ROW);
  lcd_out_cp(codetxt_to_ramtxt(" Pressione RST"));
  */
  uart1_write_text(codetxt_to_ramtxt("\r\n FIM!\r\n"));


   while(1);

}